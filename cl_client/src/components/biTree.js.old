import React, {Component} from "react";
import {biTreeColorScale} from "../scales/biTreeColorScale"
import * as d3 from "d3"
import {accumulateLeafNodesBudget, accumulateVisLeafNodes} from "../helper_functions/accumulateLeafNodes";
import {splitExperimentName} from "../helper_functions/splitExperimentName";


function evenlySampleArray(arr, n) {
    return Array.from({length: n}, (_, i) => arr[Math.floor(i * arr.length / n)]);
}

export default class BiTree extends Component {
    constructor(props) {
        super();
        this.gref = React.createRef()
        this.state = {
            parentG: null,
            size: null,
            imageSize: 100,
            paddingInner: 0.01,
            paddingOuter: 0.01,
            methodColorScale: [],
            contributions: [],
        }

        this.joinBiTree = this.joinBiTree.bind(this)
        this.setupImages = this.setupImages.bind(this)
    }

    static getDerivedStateFromProps(nextProps, prevState) {
        /*
            Whenever props change, this function will be invoked.
         */
        const {
            parentG,
            positionalHierarchyCode,
            positionalHierarchyDirection,
            methodColorScale,
            size,
            imageSize,
            translate,
            visDepth,
            contributions,
        } = nextProps;


        // Calculate the extent for both magnitude and variance
        const magExtent = d3.extent(contributions, d => d.mag_contribution);
        const varExtent = d3.extent(contributions, d => d.var_contribution);

        // Define scales based on the computed extents
        const magScale = d3.scaleLinear()
            .domain(magExtent)
            .range([0, 1]);  // Scale from 0 to 1 (to adjust for the full height of the bar)

        const varScale = d3.scaleLinear()
            .domain(varExtent)
            .range([0, 1]);  // Scale from 0 to 1 (to adjust for the full width of the bar)

        return {
            parentG,
            positionalHierarchyCode,
            positionalHierarchyDirection,
            methodColorScale,
            size,
            imageSize,
            translate,
            visDepth,
            contributions,
            magScale,
            varScale
        };
    }

    joinBiTree = () => {
        let biColorScale = biTreeColorScale([0, 10], [40, 97], 4)

        let setup_rects = (selection) => {
            /*
                Setting up the rectangle size w.r.t. the selection brush
                    - This will not be a universal solution that includes clicked nodes. Dynamic rectangle size only
                    makes sense with brushing interaction. To do this, I need to have the brush region information,
                    determine what portion of the displayed node is under the brush.
                    - Therefore, I need a switch that tells this module that the interaction type is brush.
                    - I need brush region for both direction and code hierarchy.

                I am halfway, but the change is not smooth. I think it is due to truncation and node size accumulation.
             */
            selection
                .attr('width', d => {
                    // console.log(d[0].depth, d[0].quantity, d[0].size)
                    return d[0].size
                })
                .attr('height', d => d[1].size)
                .attr('stroke', d3.hcl(0, 0, 30))
                .attr('fill', 'none')
                .attr('rx', 5)
                .attr('fill', d => {
                    let max_d = Math.max(d[0].depth, d[1].depth)
                    return biColorScale(max_d)
                })
                .transition()
        }

        let enter_ops = (enter) => {
            let g = enter.append('g')
                .attr('transform', d => `translate(${d[0].position},${d[1].position})`)
                .classed('node', true)

            // Rectangles
            g.append('rect').call(setup_rects)
            // g.append("rect").filter(d =>
            //     d[0].depth === this.state.visDepth &&
            //     d[1].depth === this.state.visDepth).call(setup_rects) // Nested Images

            // Images
            g.append("g").filter(d =>
                d[0].depth === this.state.visDepth &&
                d[1].depth === this.state.visDepth).call(this.setupImages) // Nested Images
        }

        let update_ops = (update) => {
            update
                .attr('transform', d => `translate(${d[0].position},${d[1].position})`)
                .select('rect') // This propagates data attached to group element to a child element, which is 'rect' element.
                .call(setup_rects)
        }

        // Actual join.
        d3.select(this.gref.current).selectAll('.node')
            // .filter(d => d[0].depth === 0 && d[1].depth === 0) // TODO: Track the depth of the effective root.
            .data([[this.state.positionalHierarchyDirection, this.state.positionalHierarchyCode]], d => d[0].name + '-' + d[1].name) // This is a key matching function.
            .join(
                enter => enter_ops(enter),
                update => update_ops(update),
                exit => exit.remove()
            )

        for (let i = 0; i < this.props.visDepth; i++) {
            let next_depth_g = d3.select(this.gref.current).selectAll('.node').filter(d => {
                return d[0].depth === i
            })
            next_depth_g.selectAll('.node')
                .data(d => {
                    return d3.cross(d[0].children, d[1].children)
                }, d => d[0].name + '-' + d[1].name)
                .join(
                    enter => enter_ops(enter),
                    update => update_ops(update),
                    exit => exit.remove()
                )
        }
    }

    setupImages(selection) {
        const methodColorScale = {
                'hue': d3.scaleOrdinal(
                    ["ae global", "vac global", "svmw", "sefakmc layerwise", "sefakmc global", "ganspacekmc layerwise", "ganspacekmc global", "vac layerwise", "vac_male layerwise", "vac_female layerwise", "svmw", "va layerwise", "ganspace_male", "ganspace_female"],
                    [0, 40, 80, 120, 160, 200, 240, 280, 320, 360, 30, 90, 150, 210]
                ),
                'chr': d3.scaleOrdinal(
                    ["ae global", "vac global", "svmw", "sefakmc layerwise", "sefakmc global", "ganspacekmc layerwise", "ganspacekmc global", "vac layerwise", "vac_male layerwise", "vac_female layerwise", "svmw", "va layerwise", "ganspace_male", "ganspace_female"],
                    [60, 70, 80, 50, 60, 70, 80, 90, 60, 70, 50, 80, 90, 70]
                ),
                'lum': d3.scaleOrdinal(
                    ["ae global", "vac global", "svmw", "sefakmc layerwise", "sefakmc global", "ganspacekmc layerwise", "ganspacekmc global", "vac layerwise", "vac_male layerwise", "vac_female layerwise", "svmw", "va layerwise", "ganspace_male", "ganspace_female"],
                    [40, 50, 60, 70, 80, 60, 70, 80, 50, 60, 40, 50, 60, 70]
                ),
                'lay': d3.scaleOrdinal(
                    ['early', 'middle', 'late'],
                    [0, 40, 60]
                ),
            }

        let getIndices = (codeIdx, dirIdx) => {
            let contrib = this.state.contributions.filter(d => d.direction === dirIdx && d.code === codeIdx)
            return contrib
        }

        let getImageLink = (codeIdx, flatIdx, experimentName) => {
            // const experimentName = this.props.experimentNames[treeID]
            const bucketPath = `http://localhost:${this.props.port}/served_data/${experimentName}/`
            return bucketPath + `walked/${codeIdx}-${flatIdx}.jpg`
        }

        let insertImage = (selection, imageLink, imageSize, xPos, yPos) => {
            // Sets up single image
            selection
                .attr('onerror', "this.style.display='none'")
                .attr("xlink:href", imageLink)
                .attr('transform', `translate(${xPos}, ${yPos})`)
                .attr('width', d => imageSize)
                .attr('height', d => imageSize)
                .attr('opacity', 0)
                .on('click', function(event, d) {
                    d3.select(this).raise().transition().duration(500)
                        .attr('width', d3.select(this).attr('width') == imageSize ? imageSize * 4 : imageSize)
                        .attr('height', d3.select(this).attr('height') == imageSize ? imageSize * 4 : imageSize)

                })
                // Apply transition with duration and final opacity
                .transition().duration(10) // Adjust the duration as needed
                .attr('opacity', 1) // Final opacity
        }

        // let insertContribution = (selection, magVal, varVal, xPos, yPos, imageSize) => {
        //     const gaugeWidth = 12;  // Width of the magnitude gauge bar
        //     const gaugeHeight = 5;  // Height of the variance gauge bar
        //
        //     // Use the scales from the component state
        //     const { magScale, varScale } = this.state;
        //
        //     // Scale magnitude and variance
        //     const scaledMag = magScale(magVal) * imageSize;
        //
        //     // Magnitude bar (on the right side of the image, inverted from bottom to top)
        //     selection.append('rect')
        //         .attr('x', xPos - gaugeWidth)  // Position to the right of the image with a gap
        //         .attr('y', yPos + imageSize - scaledMag)  // Start from the bottom and move up based on scaled magnitude
        //         .attr('width', gaugeWidth)
        //         .attr('height', scaledMag)  // Height based on scaled magnitude
        //         .attr('fill', d3.hcl(320, 100, 25))
        //         .attr('stroke', 'black')
        //         .style('opacity', 0.7);
        // };

        // let topG = selection.filter(d => (d[0].depth === this.state.visDepth && d[1].depth === this.state.visDepth && d[0].leaf)) // Draw only for the top boxes.
        let topG = selection.filter(d => d[0].depth === this.state.visDepth && d[1].depth === this.state.visDepth) // Draw only for the top boxes.
        topG.attr('width', d => d[0].size)
            .attr('height', d => d[1].size)

        // Number of topGs
        let topGcount = selection.size()

        let methodDrawnCount = -1
        // scales for individual boxes
        topG.each(function (d, i) {
            const width = d[0].size, height = d[1].size
            const selection = d3.select(this)
            let nodeData = selection.data()[0]

            // let imageSizeScale = d3.scaleLinear().domain([0, maxTopBox]).range([imageMaxSize, imageMinSize])
            let imageSize = 120

            // Determine how many images can fit into each box.
            let verticalCount = Math.floor(height / imageSize)  // Code budget
            let horizontalCount = Math.floor(width / imageSize) // Direction budget

            // Use width and height to determine padding.
            const horizontalPadding = (width - (imageSize * horizontalCount)) / 2
            const verticalPadding = (height - (imageSize * verticalCount)) / 2

            // Setup scales
            const horizontalScale = d3.scaleBand().domain(Array.from({length: horizontalCount}, (_, i) => i))
                .range([horizontalPadding, width - horizontalPadding]).paddingOuter(0.00).paddingInner(0.1)

            const verticalScale = d3.scaleBand().domain(Array.from({length: verticalCount}, (_, i) => i))
                .range([verticalPadding, height - verticalPadding]).paddingOuter(0.00).paddingInner(0.1)

            // console.log("BiTree Node Data: ", nodeData[0])
            let directionLeaves = accumulateLeafNodesBudget(nodeData[0])
            let codeLeaves = accumulateLeafNodesBudget(nodeData[1])
            directionLeaves = nodeData[0].leaves

            // If the budget is larger than available resources, reduce the budget
            if (directionLeaves.length < horizontalCount) {
                horizontalCount = directionLeaves.length
            }
            if (codeLeaves.length < verticalCount) {
                verticalCount = codeLeaves.length
            }
            // console.log("Image budget: ", horizontalCount, directionLeaf.length)

            // Evenly space the sampling
            // TODO: OK, this includes all "leaves." It shouldn't it needs to be filtered.
            // console.log(directionLeaves, codeLeaves)
            let directionSample = evenlySampleArray(directionLeaves, horizontalCount)
            // console.log("Direction samples: ", directionSample, directionLeaves)
            let codeSample = evenlySampleArray(codeLeaves, verticalCount)
            // console.log("Samples: ", directionNames)

            // let directionIndices = directionLeaves.map(d => d.name)
            // let codeIndices = codeLeaves.map(d => d.name)

            for (var h = 0; h < horizontalCount; h++) {
                methodDrawnCount += 1
                for (var v = 0; v < verticalCount; v++) {
                    // Determine which DFM the image comes from
                    // const treeID = directionSample[h].treeID
                    const expName = directionSample[h].expName

                    let imageLink = getImageLink(codeSample[v].name, directionSample[h].flatIdx, expName)

                    // Contribution
                    let contribUpdate = getIndices(codeSample[v].name, directionSample[h].flatIdx)

                    // Image
                    if (codeSample[v] && directionSample[h]) {
                        const xPos = horizontalScale(h)
                        const yPos = verticalScale(v)

                        selection
                            .append('image')
                            .call(insertImage,
                                imageLink,
                                horizontalScale.bandwidth(),
                                xPos,
                                yPos)

                        // Add contribution bars for magnitude and variance
                        if (contribUpdate.length > 0) {
                            let magVal = contribUpdate[0].mag_contribution;
                            let varVal = contribUpdate[0].var_contribution;

                            selection
                                .append('g')
                                .call(insertContribution, magVal, varVal, xPos, yPos, horizontalScale.bandwidth());
                        }

                        let imageSizeAdjuster = 15
                        // Only when it is the first item in the vertical
                        // if (v == 0 && methodDrawnCount < horizontalCount) {
                        if (v === 0 && methodDrawnCount < horizontalCount * topGcount) {
                            let [domainName, methodName, applicationName, layerName, layerSubName] = splitExperimentName(expName)
                            methodName = methodName + ' ' + applicationName
                            // console.log(methodName)

                            selection
                                .append('circle')
                                // .attr('width', horizontalScale.bandwidth())
                                // .attr('width', imageSize / 10)
                                // .attr('height', imageSize / 10)
                                .attr('r', imageSize / imageSizeAdjuster)
                                // .attr('transform', `translate(${xPos + horizontalScale.bandwidth() - (imageSize / imageSizeAdjuster * 2)}, ${yPos - (imageSize / imageSizeAdjuster)})`)
                                .attr('transform', `translate(${xPos + horizontalScale.bandwidth() / 2}, ${yPos - (imageSize / imageSizeAdjuster) - 2})`)
                                .attr('fill', d => {
                                    let color = d3.hcl(
                                        methodColorScale.hue(methodName),
                                        methodColorScale.chr(methodName),
                                        methodColorScale.lum(methodName) - methodColorScale.lay(layerName))
                                    return color
                                })
                                .style('stroke-width', '3.5') // Add width to the stroke
                                .style('opacity', 0.75)
                                .raise()
                        }
                    }
                }
            }
        })
    }

    componentDidUpdate(prevProps, prevState, snapshot) {
        if ((prevState.positionalHierarchyCode !== this.state.positionalHierarchyCode) ||
            (prevState.positionalHierarchyDirection !== this.state.positionalHierarchyDirection)) {

            // if (prevState.positionalHierarchyDirection !== this.state.positionalHierarchyDirection)
            //     console.log("Bi Tree: New positional hierarchy direction received")
            this.joinBiTree()
        }
    }

    render() {
        if (!this.state.translate)
            return

        return (
            <g ref={this.gref}
               transform={`translate(${this.state.translate[0]}, ${this.state.translate[1]})`}
               width={this.state.size[0]}
               height={this.state.size[1]}/>
        )
    }
}